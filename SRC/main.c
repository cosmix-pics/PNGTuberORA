#define RGFW_IMPLEMENTATION
#define RGFW_OPENGL
#define NANOVG_GL3_IMPLEMENTATION

#include "shared.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb/stb_image.h"

#define FONTSTASH_IMPLEMENTATION
#include "nanovgXC/fontstash.h"

#ifdef _WIN32
#include <windows.h>
#include <shlobj.h>
#else
#include <sys/stat.h>
#include <unistd.h>
#include <pwd.h>
#endif

#include <stdio.h>
#include <time.h>
#include <signal.h>
#include <stdlib.h>

// Crash handler
#ifdef _WIN32
static void CrashHandler(int sig) {
    const char* sigName = "Unknown";
    switch (sig) {
        case SIGSEGV: sigName = "SIGSEGV (Segmentation Fault)"; break;
        case SIGABRT: sigName = "SIGABRT (Abort)"; break;
        case SIGFPE:  sigName = "SIGFPE (Floating Point Exception)"; break;
        case SIGILL:  sigName = "SIGILL (Illegal Instruction)"; break;
    }

    char msg[256];
    snprintf(msg, sizeof(msg), "PNGTuberORA crashed!\n\nSignal: %s\n\nPlease report this issue.", sigName);
    MessageBoxA(NULL, msg, "Crash", MB_OK | MB_ICONERROR);

    exit(1);
}

static void InstallCrashHandler(void) {
    signal(SIGSEGV, CrashHandler);
    signal(SIGABRT, CrashHandler);
    signal(SIGFPE, CrashHandler);
    signal(SIGILL, CrashHandler);
}
#else
static void CrashHandler(int sig) {
    fprintf(stderr, "\n=== PNGTuberORA Crashed ===\n");
    fprintf(stderr, "Signal: %d\n", sig);
    fprintf(stderr, "Please report this issue.\n");
    exit(1);
}

static void InstallCrashHandler(void) {
    signal(SIGSEGV, CrashHandler);
    signal(SIGABRT, CrashHandler);
    signal(SIGFPE, CrashHandler);
}
#endif

// This file is generated by the build system (nob.c)
#include "font.h"

// Include viseme before audio (audio calls VisemeProcess)
#include "viseme.h"
#include "audio.h"

#include "ora_loader.h"

// Include module implementations (header-only style)
#include "pngtuber.h"
#include "menu.h"
#include "settings.h"
#include "dialog.h"

// Define globals declared in shared.h
RGFW_window* win = NULL;
NVGcontext* vg_win = NULL;
int running = 1;

// Settings window
RGFW_window* settings = NULL;
NVGcontext* vg_settings = NULL;

// Dialog window
RGFW_window* dialog = NULL;
NVGcontext* vg_dialog = NULL;

// Menu window
RGFW_window* menu = NULL;
NVGcontext* vg_menu = NULL;
int g_menuVisible = 0;

// Global application state
AppConfig g_config = {0};
Avatar g_avatar = {0};
char g_configPath[1024] = {0};
char g_visemePath[1024] = {0};
char g_dialogPath[512] = ".";

static void GetConfigPaths(void) {
#ifdef _WIN32
    char appdata[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_APPDATA, NULL, 0, appdata))) {
        snprintf(g_configPath, sizeof(g_configPath), "%s\\PNGTuberORA\\config.ini", appdata);
        snprintf(g_visemePath, sizeof(g_visemePath), "%s\\PNGTuberORA\\visemes.dat", appdata);
        // Create directory if needed
        char dir[MAX_PATH];
        snprintf(dir, sizeof(dir), "%s\\PNGTuberORA", appdata);
        CreateDirectoryA(dir, NULL);
    } else {
        strcpy(g_configPath, "config.ini");
        strcpy(g_visemePath, "visemes.dat");
    }
#else
    const char* home = getenv("HOME");
    if (!home) {
        struct passwd* pw = getpwuid(getuid());
        if (pw) home = pw->pw_dir;
    }
    if (home) {
        snprintf(g_configPath, sizeof(g_configPath), "%s/.config/pngtuberora/config.ini", home);
        snprintf(g_visemePath, sizeof(g_visemePath), "%s/.config/pngtuberora/visemes.dat", home);
        // Create directory if needed
        char dir[512];
        snprintf(dir, sizeof(dir), "%s/.config/pngtuberora", home);
        mkdir(dir, 0755);
    } else {
        strcpy(g_configPath, "config.ini");
        strcpy(g_visemePath, "visemes.dat");
    }
#endif
}

int main(void) {
    // Install crash handler first
    InstallCrashHandler();

    // Seed random for blink timing
    srand((unsigned int)time(NULL));

    // Get config and viseme paths
    GetConfigPaths();
    printf("Config path: %s\n", g_configPath);
    printf("Viseme path: %s\n", g_visemePath);

    // Load configuration
    LoadConfig(g_configPath, &g_config);

    // Initialize audio and viseme
    VisemeInit();
    VisemeLoad(g_visemePath);
    InitAudio();

    // Initialize Main Window (PNGTuber)
    pngtuber_init();
    if (!win) {
        CloseAudio();
        VisemeShutdown();
        return 1;
    }

    // Load avatar if configured
    if (g_config.defaultModelPath[0] != '\0') {
        LoadAvatarFromOra(vg_win, g_config.defaultModelPath, &g_avatar);
    }

    // Timing for animation using clock()
    clock_t lastClock = clock();

    while (running && RGFW_window_shouldClose(win) == RGFW_FALSE) {
        RGFW_pollEvents();

        // Calculate delta time
        clock_t currentClock = clock();
        float deltaTime = (float)(currentClock - lastClock) / CLOCKS_PER_SEC;
        lastClock = currentClock;

        // Update avatar state
        float volume = GetMicrophoneVolume();
        int hotkeyPressed = GetConfiguredHotkey(g_config.hotkeys, MAX_HOTKEYS);
        UpdateAvatar(&g_avatar, deltaTime, volume, g_config.voiceThreshold, hotkeyPressed);

        RGFW_event event;

        // Handle Main Window Events
        while (RGFW_window_checkQueuedEvent(win, &event)) {
            pngtuber_handle_event(&event);
        }

        // Handle Menu Window Events
        if (menu) {
            while (menu && RGFW_window_checkQueuedEvent(menu, &event)) {
                menu_handle_event(&event);
            }
            if (menu && RGFW_window_shouldClose(menu) == RGFW_TRUE) {
                menu_hide();
            }
        }

        // Handle Settings Window Events
        if (settings) {
            while (settings && RGFW_window_checkQueuedEvent(settings, &event)) {
                settings_handle_event(&event);
            }
            // Check if settings window was closed
            if (settings && RGFW_window_shouldClose(settings) == RGFW_TRUE) {
                settings_close();
            }
        }

        // Handle Dialog Window Events
        if (dialog) {
            while (dialog && RGFW_window_checkQueuedEvent(dialog, &event)) {
                dialog_handle_event(&event);
            }
            // Check if dialog window was closed
            if (dialog && RGFW_window_shouldClose(dialog) == RGFW_TRUE) {
                dialog_close();
            }
        }

        // Rendering - Main Window
        pngtuber_draw();

        // Rendering - Menu Window
        menu_draw();

        // Rendering - Settings Window
        settings_draw();

        // Rendering - Dialog Window
        dialog_draw();
    }

    // Cleanup
    CloseAudio();
    VisemeShutdown();

    if (g_avatar.isLoaded) {
        UnloadAvatar(vg_win, &g_avatar);
    }

    // Close secondary windows first
    menu_hide();
    dialog_close();
    settings_close();

#if defined(__linux__)
    backend_cleanup_x11();
#endif

    // Close main window
    if (win) {
        RGFW_window_makeCurrentContext_OpenGL(win);
        if (vg_win) nvglDelete(vg_win);
        RGFW_window_close(win);
    }

    return 0;
}
